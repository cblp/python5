<!doctype html>
<html lang="en">

<!--
    Название
Haskell для питониста.
Сравнение функциональных подходов в Haskell и Python.

    Целевая аудитория
Изучающие функциональное программирование;
разработчики на Haskell и Python.

    Тезисы:
Будущее программирования и функциональные языки.
Лёгкость обучения функциональному языку при императивном бэкграунде.
Функциональные аналоги императивных управляющих структур.
Преимущества функционального подхода.
Эффективная обработка ошибок.

    Коротко о вас
Разработчик в Яндексе, функциональный энтузиаст, преподаватель ФП в школе.
-->

    <head>
        <meta charset="utf-8">

        <title>Python 5</title>

        <meta name="description" content="">
        <meta name="author" content="Yuriy Syrovetskiy">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/yandex.css" id="theme">

        <style type="text/css">
            /*.reveal aside.notes {
                display: block;
                font-size: 14pt;
            }*/
            code {
                padding-top:    0 !important;
                padding-bottom: 0 !important;
            }
            code.emphasis {
                background: #ffcc00 !important;
            }
            code.error, code.error span {
                color: red !important;
                font-weight: bold;
            }
            h2, h3, h4, h5, h6 {
                text-align: center;
            }
            pre {
                box-shadow:     none  !important;
                margin-top:     0     !important;
                margin-bottom:  0     !important;
            }
            table {
                margin: 0 !important;
                width:  100%;
            }
        </style>

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/default.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <div class="yandexlogo yandexlogo-big"></div>
                </section>

                <section>
                    <div class="titleslide">
                        <p class="yandexdirectlogo-rus"></p>
                        <h1>Now is better<br> than never</h1>
                        <p>Юрий Сыровецкий,<br> питонист</p>
                    </div>

                    <aside class="notes">
                        Привет.
                        Меня зовут Юра, я работаю в Яндексе,
                        и разрабатываю на Питоне.
                        В анонсе я написал, что хочу рассказать о том,
                        как выглядит Хаскелл глазами питониста,
                        но сегодня я вдруг передумал и решил,
                        что лучше расскажу вам про...
                    </aside>
                </section>

                <section class="keyslide">
                    <h1>
                        &nbsp; Python

                        <aside class="notes">
                            ...Питон.

                            Как-то подходит ко мне Гвидо наш ван Россум
                            и говорит:
                            У Питона, говорит, дела плохи.
                            Двойка уже безнадёжно устрела,
                            в Тройку ещё никто не верит.
                            Новички плюются, профи плачут.
                            Надо что-то радикально менять.

                            Я сразу проснулся и решил: да! надо менять.
                            Надо создать новый Питон,
                            свободный от грехов прошлого.
                            Идеальный язык двадцать первого века!
                            Назовём его, скажем...

                            [5]

                            ...Питон 5.

                            Ну, по аналогии с Перлом 8.
                        </aside>

                        <span class="fragment" style="font-size: 130%">5</span>
                    </h1>
                </section>

                <section>
                    <h2>Совместимость</h2>

                    <aside class="notes">
                        Прежде всего, стоит сказать о совместимости.

                        Мы все видим,
                        как тяжело уже шестой год идёт переход на третий Питон,
                        и многие ещё до сих пор сидят на Двойке.
                        Традиции — это святое...

                        [ломаем]

                        ...поэтому и пятый Питон не будет совместим
                        с предыдущими версиями.
                        Всё ради прогресса и развития,
                        ради клёвых новых штук и возможностей.
                    </aside>

                    <p> Уважая традиции<span class="fragment">,<br>
                            ломаем совместимость<br>
                            во имя прогресса!
                        </span>
                    </p>
                </section>

                <section>
                    <h2>Как определить константу?</h2>

                    <aside class="notes">
                        Что же я включил в новый Питон?
                        Что мне больше всего не нравится в текущей версии —
                        это переменные.
                        Вот как вы определяете константы в Питоне?

                        [good]

                        Как-то так, верно?
                        Проблема в том,
                        что в Питоне нельзя определить константу таким образом.
                        Такая запись определяет изменяемую переменную.

                        [evil]

                        А если что-то можно изменить,
                        оно будет изменено в самый неподходящий момент,
                        что может повлечь самые неприятные последствия.
                    </aside>

                    <pre><code class="fragment">
    """ good.py """

    MAGIC = 42
                    </code> <code class="fragment">
    """ evil.py """

    import good
    good.MAGIC = 43
                    </code></pre>
                </section>

                <section>
                    <h2><code>monkey.patch()</code></h2>
                    <aside class="notes">
                        Кто-то использует эту возможность во благо.
                        Как бы во благо.
                    </aside>
                </section>

                <section>
                    <h2><code>monkey.patch()</code></h2>
                    <img src="monkey.gif" alt="monkey patching" height="480px">

                    <aside class="notes">
                        Потому что такой обезьяний жест говорит одновременно
                        и о плохой реализации вашей программы,
                        и о плохой архитектуре библиотеки,
                        которую приходится взламывать во время полёта.
                        Если бы автор предполагал,
                        что кто-то будет изменять поведение его кода на ходу,
                        он бы предоставил соответствующий интерфейс, верно?
                    </aside>
                </section>

                <section>
                    <h2>Изменяемое и неизменяемое</h2>
                    <table>
                        <tr>
                            <td>
                                <h3>Python 3</h3>
                                <pre><code>
numbers = [2, 4, 6, 8]
product = 1
for n in numbers:
    product *= n
print("The product is",
      product)
  </code> <code class="nohighlight">
The product is 384
  </code></pre>
                            </td>
                            <td class="fragment">
                                <h3>Python 5</h3>
                                <pre><code class="python">
numbers = [2, 4, 6, 8]</code><code class="emphasis">product &lt;- var 1</code><code>for n in numbers:
    product *= n
print("The product is",
      product)
  </code> <code class="nohighlight">
The product is 384
  </code></pre>
                            </td>
                        </tr>
                    </table>

                    <aside class="notes">
                        Поэтому в Питоне 5 будет строгое разделение
                        констант и изменяемые величин.

                        Этот пример содержит три изменяемых —
                        "numbers", "product" и "n",
                        при этом фактически должна изменяться только "product".

                        [5]

                        В Пятёрке привычный синтаксис со знаком "равно"
                        будет использоваться для создания констант,
                        просто потому что это нужно гораздо чаще,
                        а для изменяемых будет введён новй синтаксис.

                        Пример работает точно так же,
                        но теперь программист будет чувствовать себя спокойнее,
                        ведь он знает,
                        что у него ничего лишнего неожиданно не изменится,
                        и ничего не развалится.

                        "evil.py" с предыдущего слайда больше не будет работать.
                        И это здорово!
                    </aside>
                </section>

                <section>
                    <h2>Блоки и лямбды</h2>
                    <table>
                        <tr>
                            <td>
                                <h3>Python 3</h3>
                                <pre><code>
numbers = [2, 4, 6, 8]
product = 1
for n in numbers:
    product *= n
print("The product is",
      product)
  </code> <code class="nohighlight">
The product is 384
  </code></pre>
                            </td>
                            <td>
                                <h3>Python 5</h3>
                                <pre><code>
numbers = [2, 4, 6, 8]
product &lt;- var 1</code><code class="python emphasis">for numbers: n -></code><code>    product *= n
print("The product is",
      product)
  </code> <code class="nohighlight">
The product is 384
  </code></pre>
                            </td>
                        </tr>
                    </table>

                    <aside class="notes">
                        Следующее маленькое изменение с большим значением.

                        Давайте посмотрим, что будет,
                        если сделать блок кода объектом первого класса.
                        Он состоит из кода и принимает какие-то параметры.
                        Да это же наша старая знакомая лямбда-абстракция!
                        Синтаксис мы немножко изменим для удобочитаемости,
                        вместо ключевого слово "lambda" пусть будет стрелочка,
                        это красивее смотрится и быстрее набирается.
                    </aside>
                </section>

                <section>
                    <h2>Многострочные лямбды!</h2>
                    <pre><code class="python">
  for numbers: n ->
      print("Current sub-product is", product)
      product *= n
                    </code></pre>

                    <aside class="notes">
                        А блок с отступом после стрелки — это тело лямбды.
                        Да, ваши глаза вас не обманывают!
                        Это многострочные лямбды,
                        о необходимости которых всё время говорили большевики!
                    </aside>
                </section>

                <section>
                    <img src="morpheus-with.jpg" alt="ЧТО ЕСЛИ Я СКАЖУ, ЧТО WITH НЕ НУЖЕН?">

                    <aside class="notes">
                        Что если я скажу вам,
                        что оператор "with" не нужен в Питоне?
                    </aside>
                </section>

                <section>
                    <h2>Лямбды как блоки</h2>
                    <table>
                        <tr>
                            <td width="50%">
                                <h3>Python 3</h3>
                                <pre><code>
 def example1():
     with context() as c:
         foo(c)
         bar(c)
  </code><code class="fragment"> def example2():
     @retry(n)
     def _():
         foo()
         bar()
  </code></pre>
                            </td>
                            <td class="fragment" width="50%">
                                <h3>Python 5</h3>
                                <pre><code class="python">
 def example1():
     context(): c ->
         foo(c)
         bar(c)

 def example2():
     retry(n):
         foo()
         bar()
  </code></pre>
                            </td>
                        </tr>
                    </table>

                    <aside class="notes">
                        Когда мы используем оператор "with"?
                        Каогда нам нужно выполнить блок кода
                        в каком-то контексте, например,
                        выполнить какие-то операции до или после блока кода
                        или особым образом обработать исключения.

                        [python3/example2]

                        Но иногда нужно что-то чуть сложнее, например,
                        здесь надо попытаться выполнить блок кода ещё раз,
                        если он выполнился неуспешно.
                        В таких случаях оператор "with" не справляется,
                        и приходится изобретать что-то вот такое —
                        писать функцию со случайным именем
                        и передавать её в декоратор.
                        Но функция, которой не нужно имя, —
                        это же наша старая знакомая лямбда-абстракция!

                        [python5]

                        Соответственно,
                        мы можем просто передать функцию в функцию,
                        и внутри функции вызывать функцию
                        ноль, один или сколько угодно раз!
                        Таким образом,
                        оператор "with"
                        и отдельная концепция "менеджеров контекста"
                        становятся не нужны.
                        Проще синтаксис, проще язык, проще программы!
                        Лучше меньше, да лучше!
                        Можно и оператор "for" точно так же исключить,
                        хотя, это, пожалуй, слишком радикально.
                    </aside>
                </section>

                <section>
                    <pre><code>
  def sepulcize(sepulcas):
      return make_sepulcarium(sepulcas, bar=baz)
  </code><code class="fragment">  def make_sepulcarium(sepulcas, bar):
      return foo(bar(sepulca)
          for sepulca in walk_tree(sepulcas))
  </code><code class="fragment">  def foo(collection):
      """ Fooize a collection """
      ...

  def baz(bazable):
      """ Increases bazability.
          Takes a bazable item and
          returns an even more bazable item. """
      ...
                    </code></pre>

                    <aside class="notes">
                        Ещё одна проблема,
                        мешающая мне жить и продуктивно работать.
                        Как выглядит
                        типичная относительно сложная библиотека на Питоне,
                        которую писали не вы?
                        Она состоит из примерно вот таких функций.
                        Видно,
                        что в этой функции заключено какое-то ценное знание.
                        И, зная предметную область,
                        можно примерно понять, что она делает.
                        Но передо мной стоит более важная задача —
                        понять, как эту функцию запрягать, —
                        что конкретно ей подавать на вход,
                        и что конкретно она возвращает.

                        Исходя из кода и имён переменных,
                        можно, наверное, предположить,
                        что на входе какая-то коллекция сепулек,
                        а на выходе сепулькарий.
                        Но какая коллекция? Здесь нужен список?
                        Или достаточно генератора?
                        Давайте посмотрим в "make_sepulcarium".

                        [make_sepulcarium]

                        Оукей.
                        Тут новые непонятные слова — "foo", "bar" и "walk_tree".
                        То есть сепульки — не список и не генератор,
                        а внезапно какое-то дерево.
                        Что за дерево? Поисковое? Префиксное? Пирамида?
                        "Bar" берётся из аргументов,
                        то есть надо вернуться назад и увидеть,
                        что "bar" — это на самом деле "baz".
                        Окей, смотрим, что такое "foo" и "baz".

                        [foo]

                        Тут какие-то совсем общие вещи,
                        никак не проясняющие ситуацию.

                        [итд]

                        И так далее.
                        Что мы можем с этим сделать?
                        Было бы здорово, если бы у нас был инструмент,
                        который может проанализировать код
                        и сразу ответить на вопросы,
                        как использовать эту функцию.

                        Такой инструмент называется...
                    </aside>
                </section>

                <section>
                    <h2>Автоматический вывод типов</h2>
                    <pre><code>
  def sepulcize(sepulcas):
      ...
                    </code> <code>
  >>> from sepulcatools import *
  >>> type(sepulcize)
  sepulcize:
      yandex.util.collections.Tree[Sepulca]
        -> Optional[Sepulcarium]
                    </code></pre>

                    <aside class="notes">
                        ...автоматический вывод типов.
                        Если язык может вывести тип за нас,
                        то зачем соглашаться на меньшее?
                        В данном случае мы просто спросим
                        у интерактивного интерпретатора тип функции,
                        и сразу получим ответ.
                        Мы сразу увидим, что на входе дерево,
                        и какое конкретно дерево здесь требуется.
                        И — внезапно — оказывается, что на выходе "Optional",
                        то есть надо предусмотреть
                        случай возврата пустого значения.
                        Такую особенность мы могли легко пропустить,
                        просто читая код.
                    </aside>
                </section>

                <section class="keyslide">
                    <h2>Статическая типизация</h2>

                    <aside class="notes">
                        А вывод типов работает
                        только при поддержке в языке статической типизации.
                    </aside>
                </section>

                <section>
                    дискуссии с 2000 года:
                    <a>python.org/~guido/static-typing</a>

                    <aside class="notes">
                        О статической типизации в Питоне Гвидо ведёт дискуссии
                        с 2000 года.
                    </aside>
                </section>

                <section>
                    <img src="duck.jpg" alt="Duck">

                    <aside class="notes">
                        Многие фанаты динамической типизации считают,
                        что статическая типизация — это что-то лишнее,
                        что утка всегда утка,
                        и принудительное указание типов только отнимает время
                        при написании и чтении программ.
                    </aside>
                </section>

                <section>
                    <pre style="font-size: 0.6em;"><code class="haskell">  JavaRDD&lt;String> file = spark.textFile("hdfs://...");
  JavaRDD&lt;String> words = file.flatMap(
      new FlatMapFunction&lt;String, String>() {
          public Iterable&lt;String> call(String s) {
              return Arrays.asList(s.split(" "));
          }
      }
  );
  JavaPairRDD&lt;String, Integer> pairs = words.mapToPair(
      new PairFunction&lt;String, String, Integer>() {
          public Tuple2&lt;String, Integer> call(String s) {
              return new Tuple2&lt;String, Integer>(s, 1);
          }
      }
  );
  JavaPairRDD&lt;String, Integer> counts = pairs.reduceByKey(
      new Function2&lt;Integer, Integer>() {
          public Integer call(Integer a, Integer b) {
              return a + b;
          }
      }
  );
  counts.saveAsTextFile("hdfs://...");</code></pre>
                </section>

                <section>
                    <h2>Статическая типизация не обязана быть навязчивой</h2>
                    <pre><code class="python">
  file = spark.textFile("hdfs://...")
  words = file.flatMap(s -> s.split(" "))
  pairs = words.mapToPair(s -> (s, 1))
  counts = pairs.reduceByKey((a, b) -> a + b)
  counts.saveAsTextFile("hdfs://...")
                    </code></pre>
                </section>

                <section>
                    <h2>Типизация по желанию</h2>
                    <pre>

                    <code>
  def distance((x1, y1), (x2, y2)):
      return sqrt((x2 - x1) ** 2
                + (y2 - y1) ** 2)
                    </code></pre>
                </section>

                <section>
                    <h2>Типизация по желанию</h2>
                    <pre><code>
  distance:
      ((Float, Float), (Float, Float)) -> Float</code><code>  def distance((x1, y1), (x2, y2)):
      return sqrt((x2 - x1) ** 2
                + (y2 - y1) ** 2)
                    </code></pre>
                </section>

                <section>
                    <pre><code>
    class Color(Enum):
        Red
        Green
        Blue

    def html_code(Red):   return "#ff0000"
    def html_code(Green): return "#00ff00"</code><code class="fragment error"> Error: html_code(Blue) is not defined</code>
<code>
    print(html_code("Green"))</code><code class="error"> Error: Couldn't match expected type ‘Color’
                    with actual type ‘str’
                    </code></pre>
                    <p class="fragment">Рефакторинг без боли!</p>
                </section>

                <section>
                    <h2>HTML и шаблонизация</h2>
                    <pre><code>
    Welcome to {{ eventname }}!
                    </code></pre>
                    <blockquote class="fragment">
                        Welcome to !
                    </blockquote>
                </section>

                <section>
                    <pre><code>
    print("Welcome to {eventname}!"
          .format(event="Python&amp;Admin Party"))
    </code> <code>
    Traceback (most recent call last):
      ...
    KeyError: 'eventname'
                    </code></pre>
                </section>

                <section>
                    <pre><code>
    Welcome to {{ eventname }}!
                    </code> <code class="fragment">
    "Welcome to " + to_html(eventname) + "!"
                    </code></pre>
                    <ul class="fragment">
                        <li><code>str</code> — <code>html_escape</code></li>
                        <li><code>Markdown</code> — <code>render_markdown</code></li>
                        <li><code>HTML</code> — как есть</li>
                        <li><code>Optional</code>/<code>NoneType</code> — ошибка!</li>
                    </ul>
                </section>

                <section data-markdown>
## Статическая типизация ускоряет разработку

* Позволяет находить ошибки быстро
* Позволяет спать спокойно
* Делает код самодокументируемым, упрощая чтение
* В отличие от текстовой документации, типы всегда актуальны
                </section>

                <section class="keyslide">
                    <h2>Инструменты</h2>
                </section>

                <section>
                    <h2>Интерпретатор</h2>
                    <pre><code>
    $ ls
    hello.py

    $ python5 hello.py
    Hello world!
                    </code></pre>
                    <p class="fragment">Невалидная программа не запустится</p>
                </section>

                <section>
                    <h2>Компилятор</h2>
                    <pre><code>
    $ ls
    hello.py

    $ py5compile hello.py

    $ ls
    hello  hello.py
                    </code></pre>
                    <ul>
                        <li class="fragment">Нативный машинный код</li>
                        <li class="fragment">Скорость исполнения</li>
                    </ul>
                </section>

                <section>
                    <h2>Python 5</h2>
                </section>

                <section class="keyslide">
                    <h2>Есть такая партия!</h2>
                </section>

                <section data-markdown>
## Haskell похож на Python

* Отступы в 4 пробела
* Переменная создаётся при первом присваивании
* Необязательные аннотации типов
* Иерархическая система модулей
                </section>

                <section data-markdown>
## Haskell — то, о чём я мечтал

* Разделение изменяемого и неизменяемого
* Многострочные лямбды
* Статическая типизация
  * Автоматический вывод типов
  * Мощная система типов
* `runhaskell` для запуска скриптов
* Генерация кода из шаблонов со статической проверкой — shakespeare и другие библиотеки
* Нет GIL!
                </section>

                <section class="keyslide">
                    <h2>Учиться, учиться и учиться</h2>

                    <aside class="notes">
                        Развивайтесь.
                        Не останавливайтесь на достигнутом.
                        Изучайте новое.
                        Изучайте функциональное программирование.
                        Изучайте Хаскелл.
                        Хаскелл вовсе не так сложен, как принято думать.
                        Даже если вы не будете программировать на Хаскелле,
                        вы можете почерпнуть много интересных приёмов
                        для программирования на других языках,
                        в том числе на Питоне.
                    </aside>
                </section>

                <section class="contacts">
                    <h2>Контакты</h2>
                    <p>Юрий Сыровецкий,<br> питонист</p>
                    <p class="contact contact-mail">cblp@cblp.su</p>
                    <p class="contact contact-facebook">fb.me/cblp.su</p>
                    <p class="contact contact-twitter">@cblp_su</p>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                center: true,
                controls: false,
                history: true,
                margin: 0,
                progress: true,
                slideNumber: true,
                transition: 'fade', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies:
                  [ { src: 'lib/js/classList.js'
                    , condition: function() { return !document.body.classList; }
                    }
                  , { src: 'plugin/markdown/marked.js'
                    , condition: function() {
                          return !!document.querySelector( '[data-markdown]' );
                      }
                    }
                  , { src: 'plugin/markdown/markdown.js'
                    , condition: function() {
                          return !!document.querySelector( '[data-markdown]' );
                      }
                    }
                  , { src: 'plugin/highlight/highlight.js'
                    , async: true
                    , condition: function() {
                          return !!document.querySelector( 'pre code' );
                      }
                    , callback: function() {
                          hljs.configure({languages: ['haskell', 'python']});
                          hljs.initHighlightingOnLoad();
                      }
                    }
                  , { src: 'plugin/zoom-js/zoom.js', async: true }
                  , { src: 'plugin/notes/notes.js', async: true }
                  ]
            });

        </script>

    </body>
</html>
